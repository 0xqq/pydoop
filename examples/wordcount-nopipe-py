#!/bin/sh


# change the following exports to appropriate values for your environment
""":"
#export PATH="/ELS/els5/acdc/opt/bin:$PATH"
#export LD_LIBRARY_PATH="/ELS/els5/acdc/opt/lib:$LD_LIBRARY_PATH"

exec python -u -OO $0 ${1+"@"}
":"""


# FIXME this is a local hack that should go away in the real dist.
import sys
import os

pydoop_path = os.path.join(os.environ['HOME'],
                           'svn/ac-dc/lib/pydoop/trunk/examples')
sys.path.append(pydoop_path)

from pydoop.pipes import Mapper, Reducer, RecordReader, Factory, InputSplit
from pydoop.pipes import runTask


WORDCOUNT    = 'WORDCOUNT'
INPUT_BYTES  = 'INPUT_BYTES'
INPUT_WORDS  = 'INPUT_WORDS'
OUTPUT_WORDS = 'OUTPUT_WORDS'


def log(x):
  sys.stderr.write('%s\n' % x)


class WC_RecordReader(RecordReader):
  DEFAULT_VALUE='The quick red fox jumped on the lazy brown dog'
  def __init__(self, ctx):
    RecordReader.__init__(self)
    log('WC_RecordReader::init  start')
    log('WC_RecordReader::ctx = %s' % ctx)
    log('WC_RecordReader::input_split = >%r<' % ctx.getInputSplit())
    #log('WC_RecordReader::input_key_class = >%r<' % ctx.getInputKeyClass())
    #log('WC_RecordReader::input_value_class = >%r<' % ctx.getInputValueClass())
    self.ctx = ctx
    self.bytes_counter = 0
    self.inputBytes = ctx.getCounter(WORDCOUNT, INPUT_BYTES)
    log('WC_RecordReader::init  end')
  #-
  def next(self):
    "@return tuple(bool have_a_record, str record_key, str record_value)"
    if self.bytes_counter > 1000:
      return (False, '', '')
    delta_bytes = len(self.DEFAULT_VALUE)
    self.bytes_counter += delta_bytes
    log('WC_RecordReader::next outputting %s bytes' % delta_bytes)
    self.ctx.incrementCounter(self.inputBytes, delta_bytes)
    return (True, '%d' % self.bytes_counter, self.DEFAULT_VALUE)
  #--
  def getProgress(self):
    return float(self.bytes_counter)/1000


class WC_Mapper(Mapper):
  def __init__(self, task_ctx):
    Mapper.__init__(self)
    log('WC_Mapper::init  start')
    log('WC_Mapper::task_ctx = %s' % task_ctx)
    self.inputWords = task_ctx.getCounter(WORDCOUNT, INPUT_WORDS)
    log('WC_Mapper::init  end')
  #-
  def map(self, map_ctx):
    log('WC_Mapper::map self=%s, ctx=%s' % (self, map_ctx))
    jc = map_ctx.getJobConf()
    log('WC_Mapper::map jc[io.sort.mb =%s' % jc.getInt('io.sort.mb'))
    words = map_ctx.getInputValue().split()
    log('WC_Mapper::map: words=%r' % words)
    for w in words:
      map_ctx.emit(w, '1')
      log('WC_Mapper::map emit %s' % w)
    map_ctx.incrementCounter(self.inputWords, len(words))
    log('WC_Mapper::map end')


class WC_Reducer(Reducer):
  def __init__(self, task_ctx):
    Reducer.__init__(self)
    log('WC_Reducer::init  start')
    log('WC_Reducer::task_ctx = %s' % task_ctx)
    self.outputWords = task_ctx.getCounter(WORDCOUNT, OUTPUT_WORDS)
  #-
  def reduce(self, red_ctx):
    log('WC_Reducer::reduce self=%s, ctx=%s' % (self, red_ctx))
    s = 0
    while red_ctx.nextValue():
      s += int(red_ctx.getInputValue())
    k = red_ctx.getInputKey()
    log('WC_Reducer::reduce k=%s, s=%d' % (k, s))
    red_ctx.emit(k, str(s))
    red_ctx.incrementCounter(self.outputWords, 1)

def main(argv):
  log('wordcount started')
  runTask(Factory(WC_Mapper, WC_Reducer, WC_RecordReader))


if __name__ == "__main__":
  main(sys.argv)

# Local Variables: **
# mode: python **
# End: **
